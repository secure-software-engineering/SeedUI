diff --git a/.gitignore b/.gitignore
index c72e57c3..30671e57 100644
--- a/.gitignore
+++ b/.gitignore
@@ -14,3 +14,5 @@ libs
 obj
 examples/badcode/targets/badcode1
 examples/badcode/targets/badcode2
+kts_examples
+kts_examples/binutils-gdb
\ No newline at end of file
diff --git a/input.c b/input.c
index a1063a38..e78108eb 100644
--- a/input.c
+++ b/input.c
@@ -22,6 +22,7 @@
 
 #include "input.h"
 
+#include <bits/time.h>
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -320,28 +321,44 @@ bool input_parseBlacklist(honggfuzz_t* hfuzz) {
     return true;
 }
 
-static void input_generateFileName(dynfile_t* dynfile, const char* dir, char fname[PATH_MAX]) {
+long long current_timestamp() {
+    struct timespec spec;
+    clock_gettime(CLOCK_REALTIME, &spec);
+    return (long long)spec.tv_sec * 1000 + (long long)spec.tv_nsec / 1000000;
+}
+
+static void input_generateFileName(
+    dynfile_t* dynfile, const char* dir, char fname[PATH_MAX], run_t* run) {
     uint64_t crc64f = util_CRC64(dynfile->data, dynfile->size);
     uint64_t crc64r = util_CRC64Rev(dynfile->data, dynfile->size);
     if (dir) {
-        snprintf(fname, PATH_MAX, "%s/%016" PRIx64 "%016" PRIx64 ".%08" PRIx32 ".honggfuzz.cov",
-            dir, crc64f, crc64r, (uint32_t)dynfile->size);
+        snprintf(fname, PATH_MAX,
+            "%s/"
+            "id:%zu,executed_on:%lld,edges_found:%lu,%"
+            "016" PRIx64 "%016" PRIx64 ".%08" PRIx32 ".honggfuzz.cov",
+            dir, dynfile->idx, current_timestamp(),
+            run->global->feedback.hwCnts.softCntEdge, crc64f, crc64r,
+            (uint32_t)dynfile->size);
     } else {
-        snprintf(fname, PATH_MAX, "%016" PRIx64 "%016" PRIx64 ".%08" PRIx32 ".honggfuzz.cov",
-            crc64f, crc64r, (uint32_t)dynfile->size);
+        snprintf(fname, PATH_MAX,
+            "id:%zu,executed_on:%lld,edges_found:%lu,%"
+            "016" PRIx64 "%016" PRIx64 ".%08" PRIx32 ".honggfuzz.cov",
+            dynfile->idx, current_timestamp(),
+            run->global->feedback.hwCnts.softCntEdge, crc64f, crc64r,
+            (uint32_t)dynfile->size);
     }
 }
 
-bool input_writeCovFile(const char* dir, dynfile_t* dynfile) {
+bool input_writeCovFile(const char* dir, dynfile_t* dynfile, run_t* run) {
     char fname[PATH_MAX];
-    input_generateFileName(dynfile, dir, fname);
+    input_generateFileName(dynfile, dir, fname, run);
 
     if (files_exists(fname)) {
         LOG_D("File '%s' already exists in the output corpus directory '%s'", fname, dir);
         return true;
     }
 
-    LOG_D("Adding file '%s' to the corpus directory '%s'", fname, dir);
+    LOG_I("Adding file '%s' to the corpus directory '%s' from source '%s'", fname, dir, run->dynfile->path);
 
     if (!files_writeBufToFile(
             fname, dynfile->data, dynfile->size, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC)) {
@@ -384,11 +401,9 @@ void input_addDynamicInput(run_t* run) {
     }
     dynfile->phase    = fuzz_getState(run->global);
     dynfile->timedout = run->tmOutSignaled;
-    input_generateFileName(dynfile, NULL, dynfile->path);
 
-    MX_SCOPED_RWLOCK_WRITE(&run->global->mutex.dynfileq);
 
-    dynfile->idx = ATOMIC_PRE_INC(run->global->io.dynfileqCnt);
+ 
 
     run->global->feedback.maxCov[0] = HF_MAX(run->global->feedback.maxCov[0], dynfile->cov[0]);
     run->global->feedback.maxCov[1] = HF_MAX(run->global->feedback.maxCov[1], dynfile->cov[1]);
@@ -396,6 +411,12 @@ void input_addDynamicInput(run_t* run) {
     run->global->feedback.maxCov[3] = HF_MAX(run->global->feedback.maxCov[3], dynfile->cov[3]);
 
     run->global->io.dynfileqMaxSz = HF_MAX(run->global->io.dynfileqMaxSz, dynfile->size);
+    
+    MX_SCOPED_RWLOCK_WRITE(&run->global->mutex.dynfileq);
+    
+    dynfile->idx = ATOMIC_PRE_INC(run->global->io.dynfileqCnt);
+    
+    input_generateFileName(dynfile, NULL, dynfile->path, run);
 
     /* Sort it by coverage - put better coverage earlier in the list */
     dynfile_t* iter = NULL;
@@ -416,7 +437,7 @@ void input_addDynamicInput(run_t* run) {
 
     const char* outDir =
         run->global->io.outputDir ? run->global->io.outputDir : run->global->io.inputDir;
-    if (!input_writeCovFile(outDir, dynfile)) {
+    if (!input_writeCovFile(outDir, dynfile, run)) {
         LOG_E("Couldn't save the coverage data to '%s'", run->global->io.outputDir);
     }
 
@@ -427,7 +448,7 @@ void input_addDynamicInput(run_t* run) {
 
     ATOMIC_POST_INC(run->global->io.newUnitsAdded);
 
-    if (run->global->io.covDirNew && !input_writeCovFile(run->global->io.covDirNew, dynfile)) {
+    if (run->global->io.covDirNew && !input_writeCovFile(run->global->io.covDirNew, dynfile, run)) {
         LOG_E("Couldn't save the new coverage data to '%s'", run->global->io.covDirNew);
     }
 }
diff --git a/input.h b/input.h
index d812036c..eb705a78 100644
--- a/input.h
+++ b/input.h
@@ -38,7 +38,7 @@ extern bool           input_init(honggfuzz_t* hfuzz);
 extern bool           input_parseDictionary(honggfuzz_t* hfuzz);
 extern void           input_freeDictionary(honggfuzz_t* hfuzz);
 extern bool           input_parseBlacklist(honggfuzz_t* hfuzz);
-extern bool           input_writeCovFile(const char* dir, dynfile_t* dynfile);
+extern bool           input_writeCovFile(const char* dir, dynfile_t* dynfile, run_t* run);
 extern void           input_addDynamicInput(run_t* run);
 extern bool           input_inDynamicCorpus(run_t* run, const char* fname, size_t len);
 extern void           input_renumerateInputs(honggfuzz_t* hfuzz);
